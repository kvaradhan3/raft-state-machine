syntax = 'proto3';
package meetupRaft;

import "google/protobuf/timestamp.proto";

service RequestVoteRPC 
{
    /*
     * Invoked by candidates to gather votes (§5.2).
     */
    rpc requestVote(rv_requestor) returns (rv_voteGrant) {}
    /*
     * Receiver implementation:
     * 1. Reply false if term < currentTerm (§5.1)
     * 2. If votedFor is null or candidateId, and candidate’s log is
     *    atleast as up-to-date as receiver’s log, grant vote (§5.2,
     *    §5.4)
     */
}

message rv_requestor 
{
    google.protobuf.Timestamp send_time = 1;
    int term            = 2; /* candidate's term */
    int candidateId     = 3; /* candidate requesting vote */
    int lastLogIndex    = 4; /* index of candidate’s last log entry (§5.4) */
    int lastLogTerm     = 5; /* term of candidate’s last log entry (§5.4) */
}

message rv_voteGrant 
{
    google.protobuf.Timestamp send_time = 1;
    int term            = 2; /* currentTerm, for candidate to update itself */
    bool voteGranted    = 3; /* true means candidate received vote */
}

service AppendEntriesRPC 
{
    /*
     * Invoked by leader to replicate log entries (§5.3); also used as
     * heartbeat (§5.2).
     */
    rpc appendEntries(ae_entries) returns (ae_status) {}
    /*
     * Receiver implementation:
     * 1. Reply false if term < currentTerm (§5.1)
     * 2. Reply false if log doesn’t contain an entry at prevLogIndex
     *    whose term matches prevLogTerm (§5.3)
     * 3. If an existing entry conflicts with a new one (same index
     *    but different terms), delete the existing entry and all that
     *    follow it (§5.3)
     * 4. Append any new entries not already in the log
     * 5. If leaderCommit > commitIndex, set commitIndex =
     *    min(leaderCommit, index of last new entry)
     */
}

message ae_entries 
{
    google.protobuf.Timestamp send_time = 1;
    int term            = 2; /* leader’s term */
    int leaderId        = 3; /* so follower can redirect clients */
    int prevLogIndex    = 4; /* index of log entry immediately preceding
                              * new ones */
    int prevLogTerm     = 5; /* term of prevLogIndex entry */
    repeated
    int entries         = 6; /* log entries to store (empty for heartbeat;
                              * may send more than one for efficiency) */
    int leaderCommit    = 7; /* leader’s commitIndex */
}

message ae_status 
{
    google.protobuf.Timestamp send_time = 1;
    int term            = 2; /* currentTerm, for leader to update itself */
    bool success        = 3; /* true if follower contained entry matching
                              * prevLogIndex and prevLogTerm */
}

service InstallSnapshotRPC
{
    /*
     * Invoked by leader to send chunks of a snapshot to a follower.
     * Leaders always send chunks in order.

    rpc installSnapshot(is_snap) returns (is_myterm) {}
    /*
     * Receiver implementation:
     * 1. Reply immediately if term < currentTerm
     * 2. Create new snapshot file if first chunk (offset is 0)
     * 3. Write data into snapshot file at given offset
     * 4. Reply and wait for more data chunks if done is false
     * 5. Save snapshot file, discard any existing or partial snapshot
     *    with a smaller index
     * 6. If existing log entry has same index and term as snapshot’s
     *    last included entry, retain log entries following it and reply
     * 7. Discard the entire log
     * 8. Reset state machine using snapshot contents (and load
     *    snapshot’s cluster configuration)
     */
}

message is_snap
{
    google.protobuf.Timestamp send_time = 1;
    int term              = 2; /* leader's term */
    int leaderId          = 3; /* so follower can redirect clients */
    int lastIncludedIndex = 4; /* the snapshot replaces all entries up
                                * through and including this index */
    int lastIncludedTerm  = 5; /* term of lastIncludedIndex */
    int offset            = 6; /* byte offset where chunk is
                                * positioned in the snapshot file */
    repeated
    int data              = 7; /* raw bytes of the snapshot chunk,
                                * starting at offset */
    bool done             = 8; /* true if this is the last chunk */
}

message is_myterm
{
    google.protobuf.Timestamp send_time = 1;
    int term            = 2; /* currentTerm, for leader to update itself */
}
